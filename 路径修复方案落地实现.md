# 路径修复方案落地实现

## 方案评估结果

### 推荐方案：混合方案（编译时修正 + 服务器端兜底）⭐⭐⭐⭐⭐

**策略**：
1. **主要方案**：编译时修正（方案一）
   - 在构建前自动配置 `vite.config.js` 的 `base` 为实际路径
   - 构建后资源路径就是正确的绝对路径
   - 性能最优，符合标准做法

2. **兜底方案**：服务器端拦截（方案二）
   - 对于已构建的项目（使用相对路径）
   - 或者构建配置失败的情况
   - 服务器端自动修复

## 已实现的方案一：编译时修正

### 实现位置

**函数**：`configureProjectRoutes`（server.js 第 2624 行）

**功能**：
1. 计算项目相对于服务器根目录的相对路径
2. 构建 base 路径：`/相对路径/dist/`
3. 自动修改 `vite.config.js` 的 `base` 配置

### 实现逻辑

```javascript
// 计算相对路径（支持嵌套目录）
const relativePath = path.relative(__dirname, projectPath).replace(/\\/g, '/');
// 构建 base 路径
const basePath = '/' + relativePath + '/dist/';
// 例如：/密码服务业务线/统一密码服务平台/dist/

// 更新 vite.config.js
base: '/密码服务业务线/统一密码服务平台/dist/'
```

### 执行时机

```
Git 同步
  ↓
安装依赖
  ↓
配置路由（修改 vite.config.js 的 base）← 方案一：编译时修正
  ↓
构建项目（使用正确的 base 配置）
  ↓
完成
```

### 效果

**构建后的 HTML**：
```html
<script src="/密码服务业务线/统一密码服务平台/dist/assets/index.js"></script>
```

**优势**：
- ✅ 资源路径在构建时就是正确的
- ✅ 不需要服务器端处理
- ✅ 性能最优
- ✅ 符合标准做法

---

## 已实现的方案二：服务器端拦截（兜底）

### 实现位置

**中间件**：路由修复中间件（server.js 第 119-309 行）

**功能**：
1. 检测 HTML 中的资源路径类型
2. 如果是相对路径（`./assets/`），自动修复为绝对路径
3. 如果是绝对路径，跳过修复（说明已正确配置）

### 实现逻辑

```javascript
// 检查是否已经是绝对路径
const hasAbsolutePaths = html.match(/href="\/[^"]+assets\//) || html.match(/src="\/[^"]+assets\//);

// 如果不是绝对路径，进行修复
if (!hasAbsolutePaths && projectRelativePath) {
  const basePath = `${projectRelativePath}/dist`;
  html = html.replace(/href="\.\//g, `href="${basePath}/`);
  html = html.replace(/src="\.\//g, `src="${basePath}/`);
}
```

### 执行时机

```
用户访问 /项目路径/
  ↓
服务器拦截请求
  ↓
读取 dist/index.html
  ↓
检查资源路径类型
  ↓
如果是相对路径 → 修复为绝对路径（方案二：服务器端拦截）
如果是绝对路径 → 跳过修复（方案一已生效）
  ↓
返回 HTML
```

### 效果

**相对路径的 HTML**（方案二修复）：
```html
<!-- 原始 -->
<script src="./assets/index.js"></script>

<!-- 修复后 -->
<script src="/密码服务业务线/统一密码服务平台/dist/assets/index.js"></script>
```

**绝对路径的 HTML**（方案一已配置）：
```html
<!-- 已正确，无需修复 -->
<script src="/密码服务业务线/统一密码服务平台/dist/assets/index.js"></script>
```

---

## 方案对比

| 特性 | 方案一：编译时修正 | 方案二：服务器端拦截 |
|------|------------------|---------------------|
| **执行时机** | 构建前 | 每次请求 |
| **性能** | ⭐⭐⭐⭐⭐ 最优 | ⭐⭐⭐⭐ 良好 |
| **资源路径** | 构建时已正确 | 运行时修复 |
| **是否需要重新构建** | ✅ 是 | ❌ 否 |
| **适用场景** | 新项目 | 旧项目、兜底 |

---

## 工作流程

### 新项目（Git 同步后）

```
1. Git 同步
   ↓
2. 安装依赖
   ↓
3. 配置路由（方案一）
   - 计算相对路径
   - 修改 vite.config.js: base: '/实际路径/dist/'
   ↓
4. 构建项目
   - 使用正确的 base 配置
   - 构建后资源路径就是绝对路径
   ↓
5. 访问项目
   - 资源路径已正确，无需服务器端修复
   - 性能最优
```

### 旧项目（已构建）

```
1. 用户访问 /项目路径/
   ↓
2. 服务器拦截
   ↓
3. 读取 dist/index.html
   ↓
4. 检查资源路径
   - 如果是相对路径 → 方案二修复
   - 如果是绝对路径 → 跳过修复
   ↓
5. 返回 HTML
```

---

## 优势总结

### 方案一（编译时修正）的优势

1. ✅ **性能最优**：构建时路径已正确，无需运行时处理
2. ✅ **标准做法**：符合前端构建工具的标准流程
3. ✅ **一次配置，永久生效**：构建后文件就是正确的
4. ✅ **SEO 友好**：HTML 源码中的路径就是正确的
5. ✅ **缓存友好**：可以充分利用浏览器缓存

### 方案二（服务器端拦截）的优势

1. ✅ **无需重新构建**：不需要修改源文件，不需要重新构建
2. ✅ **自动应用**：所有项目自动生效
3. ✅ **灵活性高**：可以处理各种情况
4. ✅ **向后兼容**：支持已构建的项目

### 混合方案的优势

1. ✅ **最佳性能**：新项目使用方案一，性能最优
2. ✅ **向后兼容**：旧项目使用方案二，无需重新构建
3. ✅ **容错性强**：即使方案一失败，方案二也能修复
4. ✅ **渐进式升级**：可以逐步迁移到方案一

---

## 落地建议

### 推荐：混合方案（已实现）

**当前状态**：
- ✅ 方案一已实现：编译时自动配置 base
- ✅ 方案二已实现：服务器端自动修复（作为兜底）

**使用建议**：
1. **新项目**：使用方案一（编译时修正）
   - Git 同步后自动配置
   - 构建后路径就是正确的
   - 性能最优

2. **旧项目**：使用方案二（服务器端拦截）
   - 无需重新构建
   - 服务器端自动修复
   - 向后兼容

3. **容错处理**：
   - 如果方案一配置失败，方案二自动修复
   - 如果方案一已配置，方案二自动跳过

---

## 总结

**两种方案都已实现，采用混合策略**：

1. **方案一（编译时修正）**：主要方案，性能最优
2. **方案二（服务器端拦截）**：兜底方案，向后兼容

**推荐使用混合方案**，既保证了新项目的性能，又兼容了旧项目。

