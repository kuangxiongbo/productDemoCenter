# 大量文件上传优化方案

## 问题分析

### 当前问题
- **文件数量过多时卡顿**：一次性处理大量文件（如11726个文件）会导致：
  - 浏览器主线程阻塞
  - FormData 构建时间过长
  - 内存占用过高
  - 上传请求过大，服务器处理慢

### 根本原因
1. **同步处理**：所有文件一次性添加到 FormData
2. **单次请求**：所有文件在一个 HTTP 请求中上传
3. **无进度反馈**：文件处理阶段没有进度显示

## 解决方案：分批上传

### 方案设计

#### 1. 文件分批策略
- **每批文件数量**：50-100 个文件（可配置）
- **并行批次**：同时上传 2-3 个批次（避免过多并发）
- **动态调整**：根据文件大小自动调整批次大小

#### 2. 实现流程
```
选择文件夹（11726个文件）
    ↓
文件预处理（快速扫描，提取信息）
    ↓
分批处理（每批50个文件）
    ↓
并行上传（同时上传2-3批）
    ↓
显示进度（总体进度 + 当前批次进度）
    ↓
合并结果（所有批次完成后合并）
```

#### 3. 进度显示
- **总体进度**：已上传文件数 / 总文件数
- **当前批次进度**：当前批次的上传进度
- **速度显示**：文件/秒 或 MB/秒

### 技术实现

#### 前端实现
```javascript
// 分批上传函数
async function uploadFilesInBatches(files, batchSize = 50, maxConcurrent = 2) {
  const totalFiles = files.length;
  const batches = [];
  
  // 将文件分批
  for (let i = 0; i < files.length; i += batchSize) {
    batches.push(files.slice(i, i + batchSize));
  }
  
  let uploadedCount = 0;
  const results = [];
  
  // 并行上传批次（限制并发数）
  for (let i = 0; i < batches.length; i += maxConcurrent) {
    const currentBatches = batches.slice(i, i + maxConcurrent);
    
    const batchPromises = currentBatches.map(async (batch, batchIndex) => {
      const formData = new FormData();
      // 添加批次文件...
      
      const result = await uploadBatch(formData);
      uploadedCount += batch.length;
      updateProgress(uploadedCount, totalFiles);
      return result;
    });
    
    await Promise.all(batchPromises);
  }
  
  return results;
}
```

#### 后端支持
- 支持部分文件上传
- 返回已上传文件列表
- 支持断点续传（记录已上传文件）

### 性能优化

#### 1. 文件预处理优化
- 使用 `requestIdleCallback` 在空闲时处理文件列表
- 使用 `Web Worker` 处理大量文件信息提取

#### 2. 内存优化
- 每批上传完成后释放内存
- 使用流式处理，避免一次性加载所有文件

#### 3. 网络优化
- 压缩文件信息（只传递必要数据）
- 使用 HTTP/2 多路复用（如果支持）

## 实施优先级

### 第一阶段（立即实施）
1. ✅ **分批上传** - 将文件分成小批次上传
2. ✅ **进度显示优化** - 显示总体进度和当前批次进度

### 第二阶段（短期优化）
3. ✅ **并行批次** - 同时上传多个批次
4. ✅ **错误恢复** - 失败批次自动重试

### 第三阶段（长期优化）
5. ✅ **Web Worker** - 使用 Worker 处理文件列表
6. ✅ **断点续传** - 支持上传中断后恢复


