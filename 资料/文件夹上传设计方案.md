# 文件夹上传完整设计方案

## 1. 需求分析

### 1.1 核心需求
- 上传选中的文件夹（包含文件夹本身）
- 保持完整的目录结构（所有子文件夹和文件）
- 支持多层嵌套子目录
- 避免文件名冲突导致文件丢失
- 确保所有文件都保存到正确的位置

### 1.2 当前问题
1. **文件名冲突**：不同子目录下的同名文件在临时目录中会相互覆盖
2. **路径信息丢失**：`req.body.filePaths` 在 `destination` 函数中可能不可用
3. **文件匹配困难**：临时文件名和原始路径的匹配逻辑复杂
4. **多层子目录处理**：可能存在路径解析错误

## 2. 设计方案

### 2.1 整体架构

```
前端选择文件夹
    ↓
提取所有文件的 webkitRelativePath
    ↓
构建完整的文件路径映射
    ↓
发送到后端（包含路径信息）
    ↓
后端接收并解析
    ↓
创建目录结构
    ↓
保存文件到正确位置（一次性到位，无需移动）
```

### 2.2 前端设计

#### 2.2.1 文件信息收集
```javascript
// 收集所有文件信息
const filesInfo = [];
for (let i = 0; i < files.length; i++) {
  const file = files[i];
  const relativePath = file.webkitRelativePath || file.name;
  
  filesInfo.push({
    file: file,                    // File 对象
    relativePath: relativePath,   // 完整相对路径：folderName/sub1/sub2/file.html
    fileName: path.basename(relativePath),  // 文件名
    directoryPath: path.dirname(relativePath) // 目录路径（相对于文件夹根目录）
  });
}
```

#### 2.2.2 目录结构提取
```javascript
// 提取所有需要创建的目录路径
const directorySet = new Set();
filesInfo.forEach(info => {
  if (info.directoryPath && info.directoryPath !== '.') {
    // 提取所有层级的目录路径
    // 例如：sub1/sub2/sub3 -> ['sub1', 'sub1/sub2', 'sub1/sub2/sub3']
    const parts = info.directoryPath.split('/').filter(p => p);
    let currentPath = '';
    parts.forEach(part => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      directorySet.add(currentPath);
    });
  }
});
```

#### 2.2.3 数据传递方式
```javascript
// 方案A：使用 FormData（当前方式，但需要改进）
const formData = new FormData();
formData.append('targetPath', targetPath);
formData.append('folderName', folderName);  // 上传的文件夹名称
formData.append('directoryPaths', JSON.stringify(Array.from(directorySet)));
formData.append('filesInfo', JSON.stringify(filesInfo.map(f => ({
  relativePath: f.relativePath,
  fileName: f.fileName,
  directoryPath: f.directoryPath
}))));

// 每个文件使用唯一标识符
filesInfo.forEach((info, index) => {
  // 使用索引作为唯一标识，避免文件名冲突
  formData.append('files', info.file, `file_${index}_${info.fileName}`);
});
```

### 2.3 后端设计

#### 2.3.1 存储策略选择

**方案A：临时目录 + 移动（当前方案，存在问题）**
- ❌ 文件名冲突风险
- ❌ 需要额外的移动操作
- ❌ 路径匹配复杂

**方案B：直接保存到目标位置（推荐）**
- ✅ 避免文件名冲突
- ✅ 无需移动操作
- ✅ 路径清晰明确

#### 2.3.2 推荐方案：直接保存到目标位置

**核心思路**：
1. 在 `destination` 函数中，根据 `originalname` 或文件索引，直接确定目标目录
2. 使用文件索引作为临时文件名，避免冲突
3. 在 `filename` 函数中，使用索引生成唯一文件名
4. 在 `/api/upload` 端点中，根据索引和 `filesInfo` 将文件重命名为正确名称

#### 2.3.3 实现细节

**Step 1: 文件上传（使用索引作为临时文件名）**
```javascript
// filename 函数
filename: function (req, file, cb) {
  // 从 fieldname 中提取索引（如果前端传递了）
  // 或者使用全局计数器
  const fileIndex = req.fileIndex || 0;
  req.fileIndex = (req.fileIndex || 0) + 1;
  
  // 临时文件名：使用索引确保唯一性
  const tempFileName = `temp_${fileIndex}_${Date.now()}`;
  cb(null, tempFileName);
}
```

**Step 2: 确定目标目录**
```javascript
// destination 函数
destination: function (req, file, cb) {
  // 方案：先保存到临时目录，后续统一处理
  // 或者：根据文件索引和 filesInfo 直接确定目标目录
  
  // 临时方案：先保存到目标根目录
  const targetPath = req.body.targetPath || __dirname;
  cb(null, targetPath);
}
```

**Step 3: 文件重命名和移动（在 /api/upload 端点）**
```javascript
// 解析 filesInfo
const filesInfo = JSON.parse(req.body.filesInfo);

// 创建目录结构
const directoryPaths = JSON.parse(req.body.directoryPaths);
// ... 创建所有目录 ...

// 处理每个文件
req.files.forEach((file, index) => {
  const info = filesInfo[index];
  if (!info) return;
  
  // 构建目标路径
  const targetDir = path.join(targetPath, info.directoryPath || '');
  const targetFilePath = path.join(targetDir, info.fileName);
  
  // 移动并重命名文件
  fs.renameSync(file.path, targetFilePath);
});
```

## 3. 优化方案（推荐）

### 3.1 方案：使用文件索引 + 后处理

**优点**：
- 避免文件名冲突（使用索引）
- 路径信息完整（通过 filesInfo）
- 逻辑清晰（先保存，后处理）

**实现步骤**：

1. **前端**：
   - 收集所有文件信息（路径、文件名、目录）
   - 使用索引作为文件标识
   - 传递 `filesInfo` JSON 数据

2. **后端 - destination**：
   - 所有文件先保存到目标根目录
   - 使用索引作为临时文件名

3. **后端 - /api/upload**：
   - 解析 `filesInfo` 和 `directoryPaths`
   - 创建所有目录结构
   - 根据索引匹配文件并移动到正确位置
   - 重命名为原始文件名

### 3.2 方案：使用内存存储 + 一次性写入（备选）

**优点**：
- 完全避免文件名冲突
- 可以验证所有文件后再写入

**缺点**：
- 内存占用较大（不适合大文件）
- 实现复杂度较高

## 4. 推荐实现方案

### 4.1 前端改进

```javascript
// 1. 收集文件信息
const filesInfo = [];
const directorySet = new Set();

files.forEach((file, index) => {
  const relativePath = file.webkitRelativePath || file.name;
  const parts = relativePath.split('/').filter(p => p);
  const folderName = parts[0];  // 第一层是文件夹名称
  const subPath = parts.slice(1).join('/');  // 子路径
  
  // 提取目录路径（去掉文件夹名称和文件名）
  const dirParts = parts.slice(1, -1);
  const directoryPath = dirParts.join('/');
  
  filesInfo.push({
    index: index,
    relativePath: relativePath,
    fileName: parts[parts.length - 1],
    directoryPath: directoryPath,
    folderName: folderName
  });
  
  // 收集目录路径
  if (directoryPath) {
    const dirParts = directoryPath.split('/');
    let currentPath = '';
    dirParts.forEach(part => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      directorySet.add(currentPath);
    });
  }
});

// 2. 构建 FormData
const formData = new FormData();
formData.append('targetPath', targetPath);
formData.append('folderName', folderName);
formData.append('filesInfo', JSON.stringify(filesInfo));
formData.append('directoryPaths', JSON.stringify(Array.from(directorySet)));

// 3. 上传文件（使用索引作为标识）
files.forEach((file, index) => {
  // 使用索引确保唯一性
  formData.append('files', file, `file_${index}`);
});
```

### 4.2 后端改进

```javascript
// 1. destination 函数：所有文件先保存到目标根目录
destination: function (req, file, cb) {
  const targetPath = req.body.targetPath || __dirname;
  const resolvedPath = path.resolve(targetPath);
  
  // 确保目录存在
  if (!fs.existsSync(resolvedPath)) {
    fs.mkdirSync(resolvedPath, { recursive: true });
  }
  
  cb(null, resolvedPath);
}

// 2. filename 函数：使用索引作为临时文件名
filename: function (req, file, cb) {
  // 从 fieldname 提取索引（如果前端传递了 file_0, file_1 格式）
  let index = 0;
  if (file.fieldname && file.fieldname.startsWith('file_')) {
    const match = file.fieldname.match(/file_(\d+)/);
    if (match) {
      index = parseInt(match[1]);
    }
  }
  
  // 使用索引和时间戳确保唯一性
  const tempFileName = `temp_${index}_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  cb(null, tempFileName);
}

// 3. /api/upload 端点：处理文件移动
app.post('/api/upload', upload.array('files'), (req, res) => {
  // 解析文件信息
  const filesInfo = JSON.parse(req.body.filesInfo);
  const directoryPaths = JSON.parse(req.body.directoryPaths);
  const targetPath = path.resolve(req.body.targetPath || __dirname);
  const folderName = req.body.folderName;
  
  // 1. 创建所有目录结构
  const sortedDirs = Array.from(directoryPaths).sort((a, b) => {
    return (a.match(/\//g) || []).length - (b.match(/\//g) || []).length;
  });
  
  sortedDirs.forEach(dirPath => {
    const fullPath = path.join(targetPath, folderName, dirPath);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
  });
  
  // 2. 移动文件到正确位置
  req.files.forEach((file, index) => {
    const info = filesInfo[index];
    if (!info) {
      console.warn(`[upload] 文件 ${index} 没有对应的信息`);
      return;
    }
    
    // 构建目标路径
    const targetDir = path.join(targetPath, folderName, info.directoryPath || '');
    const targetFilePath = path.join(targetDir, info.fileName);
    
    // 确保目标目录存在
    if (!fs.existsSync(targetDir)) {
      fs.mkdirSync(targetDir, { recursive: true });
    }
    
    // 移动文件
    if (fs.existsSync(file.path)) {
      fs.renameSync(file.path, targetFilePath);
      file.path = targetFilePath;  // 更新路径
    }
  });
  
  // 3. 返回结果
  res.json({ success: true, ... });
});
```

## 5. 关键改进点

### 5.1 避免文件名冲突
- ✅ 使用文件索引作为临时文件名
- ✅ 每个文件都有唯一标识
- ✅ 不会相互覆盖

### 5.2 路径信息传递
- ✅ 通过 `filesInfo` JSON 传递完整路径信息
- ✅ 不依赖 `req.body` 在 `destination` 中的可用性
- ✅ 路径信息完整可靠

### 5.3 文件匹配
- ✅ 通过索引直接匹配（`filesInfo[index]` 对应 `req.files[index]`）
- ✅ 无需复杂的哈希匹配
- ✅ 逻辑简单清晰

### 5.4 目录结构创建
- ✅ 先创建所有目录，再移动文件
- ✅ 按层级排序，确保父目录先创建
- ✅ 支持任意深度的嵌套

## 6. 实施步骤

1. **修改前端**：使用索引作为文件标识，传递 `filesInfo`
2. **修改后端 destination**：简化逻辑，所有文件先保存到目标根目录
3. **修改后端 filename**：使用索引生成唯一临时文件名
4. **修改后端 /api/upload**：根据索引匹配文件并移动到正确位置
5. **测试验证**：测试多层子目录、同名文件等场景

## 7. 测试场景

1. **单层目录**：文件夹下直接有文件
2. **多层目录**：folder/sub1/sub2/file.html
3. **同名文件**：不同子目录下有同名文件
4. **中文路径**：目录和文件名包含中文
5. **特殊字符**：文件名包含特殊字符
6. **空目录**：包含空子目录
7. **大量文件**：上传包含大量文件的文件夹

